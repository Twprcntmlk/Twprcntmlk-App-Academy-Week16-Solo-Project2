{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/**\n * @module ol/Observable\n */\n\n\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport { listen, listenOnce, unlistenByKey } from './events.js';\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * An event target providing convenient methods for listener registration\n * and unregistration. A generic `change` event is always available through\n * {@link module:ol/Observable~Observable#changed}.\n *\n * @fires import(\"./events/Event.js\").default\n * @api\n */\n\nvar Observable =\n/** @class */\nfunction (_super) {\n  __extends(Observable, _super);\n\n  function Observable() {\n    var _this = _super.call(this) || this;\n    /**\n     * @private\n     * @type {number}\n     */\n\n\n    _this.revision_ = 0;\n    return _this;\n  }\n  /**\n   * Increases the revision counter and dispatches a 'change' event.\n   * @api\n   */\n\n\n  Observable.prototype.changed = function () {\n    ++this.revision_;\n    this.dispatchEvent(EventType.CHANGE);\n  };\n  /**\n   * Get the version number for this object.  Each time the object is modified,\n   * its version number will be incremented.\n   * @return {number} Revision.\n   * @api\n   */\n\n\n  Observable.prototype.getRevision = function () {\n    return this.revision_;\n  };\n  /**\n   * Listen for a certain type of event.\n   * @param {string|Array<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n   *     called with an array of event types as the first argument, the return\n   *     will be an array of keys.\n   * @api\n   */\n\n\n  Observable.prototype.on = function (type, listener) {\n    if (Array.isArray(type)) {\n      var len = type.length;\n      var keys = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        keys[i] = listen(this, type[i], listener);\n      }\n\n      return keys;\n    } else {\n      return listen(this,\n      /** @type {string} */\n      type, listener);\n    }\n  };\n  /**\n   * Listen once for a certain type of event.\n   * @param {string|Array<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n   *     called with an array of event types as the first argument, the return\n   *     will be an array of keys.\n   * @api\n   */\n\n\n  Observable.prototype.once = function (type, listener) {\n    var key;\n\n    if (Array.isArray(type)) {\n      var len = type.length;\n      key = new Array(len);\n\n      for (var i = 0; i < len; ++i) {\n        key[i] = listenOnce(this, type[i], listener);\n      }\n    } else {\n      key = listenOnce(this,\n      /** @type {string} */\n      type, listener);\n    }\n    /** @type {Object} */\n\n\n    listener.ol_key = key;\n    return key;\n  };\n  /**\n   * Unlisten for a certain type of event.\n   * @param {string|Array<string>} type The event type or array of event types.\n   * @param {function(?): ?} listener The listener function.\n   * @api\n   */\n\n\n  Observable.prototype.un = function (type, listener) {\n    var key =\n    /** @type {Object} */\n    listener.ol_key;\n\n    if (key) {\n      unByKey(key);\n    } else if (Array.isArray(type)) {\n      for (var i = 0, ii = type.length; i < ii; ++i) {\n        this.removeEventListener(type[i], listener);\n      }\n    } else {\n      this.removeEventListener(type, listener);\n    }\n  };\n\n  return Observable;\n}(EventTarget);\n/**\n * Removes an event listener using the key returned by `on()` or `once()`.\n * @param {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} key The key returned by `on()`\n *     or `once()` (or an array of keys).\n * @api\n */\n\n\nexport function unByKey(key) {\n  if (Array.isArray(key)) {\n    for (var i = 0, ii = key.length; i < ii; ++i) {\n      unlistenByKey(key[i]);\n    }\n  } else {\n    unlistenByKey(\n    /** @type {import(\"./events.js\").EventsKey} */\n    key);\n  }\n}\nexport default Observable;","map":{"version":3,"sources":["src/Observable.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/Observable\n */\nimport EventTarget from './events/Target.js';\nimport EventType from './events/EventType.js';\nimport { listen, listenOnce, unlistenByKey } from './events.js';\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * An event target providing convenient methods for listener registration\n * and unregistration. A generic `change` event is always available through\n * {@link module:ol/Observable~Observable#changed}.\n *\n * @fires import(\"./events/Event.js\").default\n * @api\n */\nvar Observable = /** @class */ (function (_super) {\n    __extends(Observable, _super);\n    function Observable() {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {number}\n         */\n        _this.revision_ = 0;\n        return _this;\n    }\n    /**\n     * Increases the revision counter and dispatches a 'change' event.\n     * @api\n     */\n    Observable.prototype.changed = function () {\n        ++this.revision_;\n        this.dispatchEvent(EventType.CHANGE);\n    };\n    /**\n     * Get the version number for this object.  Each time the object is modified,\n     * its version number will be incremented.\n     * @return {number} Revision.\n     * @api\n     */\n    Observable.prototype.getRevision = function () {\n        return this.revision_;\n    };\n    /**\n     * Listen for a certain type of event.\n     * @param {string|Array<string>} type The event type or array of event types.\n     * @param {function(?): ?} listener The listener function.\n     * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n     *     called with an array of event types as the first argument, the return\n     *     will be an array of keys.\n     * @api\n     */\n    Observable.prototype.on = function (type, listener) {\n        if (Array.isArray(type)) {\n            var len = type.length;\n            var keys = new Array(len);\n            for (var i = 0; i < len; ++i) {\n                keys[i] = listen(this, type[i], listener);\n            }\n            return keys;\n        }\n        else {\n            return listen(this, /** @type {string} */ (type), listener);\n        }\n    };\n    /**\n     * Listen once for a certain type of event.\n     * @param {string|Array<string>} type The event type or array of event types.\n     * @param {function(?): ?} listener The listener function.\n     * @return {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} Unique key for the listener. If\n     *     called with an array of event types as the first argument, the return\n     *     will be an array of keys.\n     * @api\n     */\n    Observable.prototype.once = function (type, listener) {\n        var key;\n        if (Array.isArray(type)) {\n            var len = type.length;\n            key = new Array(len);\n            for (var i = 0; i < len; ++i) {\n                key[i] = listenOnce(this, type[i], listener);\n            }\n        }\n        else {\n            key = listenOnce(this, /** @type {string} */ (type), listener);\n        }\n        /** @type {Object} */ (listener).ol_key = key;\n        return key;\n    };\n    /**\n     * Unlisten for a certain type of event.\n     * @param {string|Array<string>} type The event type or array of event types.\n     * @param {function(?): ?} listener The listener function.\n     * @api\n     */\n    Observable.prototype.un = function (type, listener) {\n        var key = /** @type {Object} */ (listener).ol_key;\n        if (key) {\n            unByKey(key);\n        }\n        else if (Array.isArray(type)) {\n            for (var i = 0, ii = type.length; i < ii; ++i) {\n                this.removeEventListener(type[i], listener);\n            }\n        }\n        else {\n            this.removeEventListener(type, listener);\n        }\n    };\n    return Observable;\n}(EventTarget));\n/**\n * Removes an event listener using the key returned by `on()` or `once()`.\n * @param {import(\"./events.js\").EventsKey|Array<import(\"./events.js\").EventsKey>} key The key returned by `on()`\n *     or `once()` (or an array of keys).\n * @api\n */\nexport function unByKey(key) {\n    if (Array.isArray(key)) {\n        for (var i = 0, ii = key.length; i < ii; ++i) {\n            unlistenByKey(key[i]);\n        }\n    }\n    else {\n        unlistenByKey(/** @type {import(\"./events.js\").EventsKey} */ (key));\n    }\n}\nexport default Observable;\n//# sourceMappingURL=Observable.js.map"]},"metadata":{},"sourceType":"module"}